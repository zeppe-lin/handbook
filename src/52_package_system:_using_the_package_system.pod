=head2 Using the Package System

=head3 B<Installing a package>

Installing a package is done by using L<pkgadd(8)>.  This utility
requires at least one argument, the package you want to install.
Example:

    # pkgadd bash#5.0.18-1.pkg.tar.gz

When installing a package the package manager will ensure that no
previously installed files are overwritten.  If conflicts are found,
an error message will be printed and L<pkgadd(8)> will abort without
installing the package.  The error message will contain the names of
the conflicting files.  Example:

    # pkgadd bash#5.0.18-1.pkg.tar.gz
    bin/sh
    usr/share/man/man1/sh.1.gz
    pkgadd error: listed files already installed
        (use -f to ignore and overwrite)

To force the installation and overwrite the conflicting files, you
can use the option B<-f>/B<--force>.  Example:

    # pkgadd -f bash#5.0.18-1.pkg.tar.gz

The package system allows a file to be owned by exactly one package.
When forcing an installation the ownership of the conflicting files
will be transferred to the package that is currently being installed.
Directories can however be owned by more than one package.

=begin man

.TS
center, box, tab (|) ;
c
c.
<WARNING>
_
.SP
It is often not a good idea to force the installation
unless you really know what you are doing.  If a package
conflicts with already installed files it could be a sign
that the package is broken and installs unexpected files.
Use this option with extreme care, preferably not at all.
.TE

=end man

=begin html

    <table>
        <tr>
            <th>WARNING</th>
        </tr>

        <tr>
            <td>
                It is often not a good idea to force the installation
                unless you really know what you are doing.  If a
                package conflicts with already installed files it
                could be a sign that the package is broken and
                installs unexpected files.  Use this option with
                extreme care, preferably not at all.
            </td>
        </tr>
    </table>

=end html

As earlier, the package file itself does not contain any metadata.
Instead, the L<pkgadd(8)> uses the package filename to determine the
package name and version.  Thus, when installing a package file named
I<bash#5.0.18-1.pkg.tar.gz>, L<pkgadd(8)> will interpret this as a
package named I<bash> at version I<5.0.18-1>.  If L<pkgadd(8)> is
unable to interpret the filename (e.g. B<#> is missing or the filename
does not end with .pkg.tar.gz) an error message will be printed and
L<pkgadd(8)> will abort without installing the package.

=head3 B<Upgrading a package>

Upgrading a package is done using L<pkgadd(8)> with the B<-u> option.
Example:

    # pkgadd -u bash#5.0.18-1.pkg.tar.gz

This will replace the previously installed bash package with the new
one.  If you have not previously installed bash, L<pkgadd(8)> will
print an error message.  L<pkgadd(8)> does not care about the version
number of the package in that you can "upgrade" version 2.05-1 with
version 2.04-1 (or even with version 2.05-1 itself).  The installed
package will be replaced with the specified package.

Upgrading a package is equivalent to executing L<pkgrm(8)> followed by
L<pkgadd(8)> with one (big) exception.  When upgrading a package (with
C<pkgadd -u>) you have the option to prevent some of the already
installed files from getting replaced.  This is typically useful when
you want to preserve configuration and log files.

When executing L<pkgadd(8)> the file F</etc/pkgadd.conf> will be read.
This file can contain rules describing how L<pkgadd(8)> should behave
when doing upgrades.  A rule is built out of three fragments:
I<event>, I<pattern>, and I<action>.  The I<event> describes in what
kind of situation this rule applies.  Currently, only one type of
event is supported, that is UPGRADE.  The I<pattern> is a filename
pattern expressed as a regular expression and the I<action> applicable
to the UPGRADE event is YES or NO.  More than one rule of the same
event type is allowed, in which case the first rule will have the
lowest priority and the last rule will have the highest priority.
Example:

    #
    # /etc/pkgadd.conf: pkgadd(8) configuration
    #

    UPGRADE       ^etc/.*$                NO
    UPGRADE       ^var/log/.*$            NO
    UPGRADE       ^etc/X11/.*$           YES
    UPGRADE       ^etc/X11/xorg.conf$     NO

    # End of file.

The above example will cause L<pkgadd(8)> to never upgrade anything in
F</etc/> or F</var/log/> (subdirectories included), except files in
F</etc/X11/> (subdirectories included), unless it's the file
F</etc/X11/xorg.conf>.  The default rule is to upgrade everything,
rules in this file are exceptions to that rule.

B<NOTE:> A pattern should never contain an initial "/" since you are
referring to the files in the package, not the files on the disk.

See L<pkgadd.conf(5)> for more information.

=head4 I<Rejected files>

If L<pkgadd(8)> finds that a specific file should not be upgraded, it
will install it under F</var/lib/pkg/rejected/>.  Files in this
directory are never added to the package database.  The user is then
free to examine, use and/or remove that file manually.  Another option
is to use L<rejmerge(8)>.  For each rejected file found in
F</var/lib/pkg/rejected/>, L<rejmerge(8)> will display the difference
between the installed version and the rejected version.  The user can
then choose to keep the installed version, upgrade to the rejected
version or perform a merge of the two.  Example (using the above
F</etc/pkgadd.conf>):

    # pkgadd -u bash#5.0.18-1.pkg.tar.gz
    pkgadd: rejecting etc/profile, keeping existing version

    # tree --charset=ascii /var/lib/pkg/rejected
    /var/lib/pkg/rejected
    `-- etc
        `-- profile

=head3 B<Removing a package>

Removing a package is done by using L<pkgrm(8)>.  This utility
requires one argument, the name of the package you want to remove.
Example:

    # pkgrm bash

=begin man

.TS
center, box, tab (|) ;
c
c.
<WARNING>
_
.SP
This will remove all files owned by the package, no questions
asked.  Think twice before doing it and make sure that you did
not misspell the package name since that could remove something
completely different (e.g., think about what could happen if
you misspelled glib as glibc).
.TE

=end man

=begin html

    <table>
        <tr>
            <th>WARNING</th>
        </tr>

        <tr>
            <td>
                This will remove all files owned by the package, no
                questions asked.  Think twice before doing it and make
                sure that you did not misspell the package name since
                that could remove something completely different (e.g.
                think about what could happen if you misspelled glib
                as glibc).
            </td>
        </tr>
    </table>

=end html

=head3 B<Querying the package database>

Querying the package database is done using L<pkginfo(1)>.  This
utility has a few options to answer different queries.

=begin man

.TS
center, box, tab (@) ;
l | l
l | l.
Option @ Description
_
-f, --footprint=FILE@print footprint for FILE
-i, --installed@list installed packages and their version
-l, --list=PACKAGE|FILE@list files in PACKAGE or FILE
-o, --owner=PATTERN@list owner(s) of file(s) matching PATTERN
-r, --root=DIR@specify an alternate root directory
-v, --version@print version and exit
-h, --help@print help and exit
.TE

=end man

=begin html

    <table>
        <tr>
            <th>Option</th>
            <th>Description</th>
        </tr>
        <tr>
            <td>-f, --footprint=FILE</td>
            <td>print footprint for FILE</td>
        </tr>
        <tr>
            <td>-i, --installed</td>
            <td>list installed packages and their version</td>
        </tr>
        <tr>
            <td>-l, --list=PACKAGE|FILE</td>
            <td>list files in PACKAGE or FILE</td>
        </tr>
        <tr>
            <td>-o, --owner=PATTERN</td>
            <td>list owner(s) of file(s) matching PATTERN</td>
        </tr>
        <tr>
            <td>-r, --root=DIR</td>
            <td>specify an alternate root directory</td>
        </tr>
        <tr>
            <td>-v, --version</td>
            <td>print version and exit</td>
        </tr>
        <tr>
            <td>-h, --help</td>
            <td>print help and exit</td>
        </tr>
    </table>

=end html

=head4 I<List installed packages and their version>

    $ pkginfo -i
    audiofile 0.2.3-1
    autoconf 2.52-1
    automake 1.5-1
    [...]
    xmms 1.2.7-1
    zip 2.3-1
    zlib 1.1.4-1

=head4 I<List files in PACKAGE or FILE>

    $ pkginfo -l bash
    bin/
    bin/bash
    etc/
    etc/profile
    usr/
    usr/share/man/
    usr/share/man/man1/
    usr/share/man/man1/bash.1.gz

    $ pkginfo -l grep#2.5-1.pkg.tar.gz
    usr/
    usr/bin/
    usr/bin/egrep
    usr/bin/fgrep
    usr/bin/grep
    usr/share/man/
    usr/share/man/man1/
    usr/share/man/man1/egrep.1.gz
    usr/share/man/man1/fgrep.1.gz
    usr/share/man/man1/grep.1.gz

=head4 I<List owners of files matching F<bin/ls>>

    $ pkginfo -o bin/ls
    e2fsprogs  usr/bin/lsattr
    fileutils  bin/ls
    modutils   sbin/lsmod

=head4 I<Print footprint for file>

    $ pkginfo -f xorg-xkill#1.0.5-1.pkg.tar.gz
    drwxr-xr-x      root/root       usr/
    drwxr-xr-x      root/root       usr/share/
    drwxr-xr-x      root/root       usr/bin/
    -rwxr-xr-x      root/root       usr/bin/xkill
    drwxr-xr-x      root/root       usr/share/man/
    drwxr-xr-x      root/root       usr/share/man/man1/
    -rw-r--r--      root/root       usr/share/man/man1/xkill.1.gz

This feature is mainly used by L<pkgmk(8)> for creating and comparing
footprints.

The B<-r>/B<--root> option should be used if you want to display
information about a package that is installed on a temporarily mounted
partition, which is "owned" by another system.  By using this option
you specify which database to use.

=cut

# vim: sw=4 ts=4 sts=4 et cc=72 tw=70
